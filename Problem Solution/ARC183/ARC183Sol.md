# B

```
Quality = 高
Difficulty = 2118
Personal_Difficulty = NOIP_T2.5
Time = 2025.9.23
Tag = 思维 分析
```

## 题解

首先，如果 $B$ 中出现了 $A$ 中没有的数，答案肯定是 `NO`。如果 $A = B$，答案肯定是 `YES`。

**整题最重要观察：如果有一个自由点且 $k > 1$，那么我们可以随意交换任意相邻的两个数。**

> 证明：考虑每次把自由点往这两个数靠近，如果距离 $\leq k$，那么我们就可以以自由点为中转站来进行交换。 

推论显而易见：如果有一个自由点且 $k > 1$，那么我们可以任意重排整个序列（除了自由点），并且每个数都可以等于在 $A$ 中有的值。

先考虑 $k = 1$，那么只能相邻赋值，显然最后的答案形如一段一段的相等数，可以给 $B$ 压块后判断是否是子序列。

然后考虑 $k > 1$，如果有自由点，由于推论且元素集合是一样的，肯定有解。因此，问题转化为是否存在自由点。

我们考虑刻画自由点，这是一个下标 $p$，使得别的数都和 $B$ 相等的时候，存在一个数能给他赋值，使得 $a_p = b_p$。那么，这其实就是问是否存在 $b_i = b_p, |i - p| \leq k$，而这个很好判断。

## 实现

* 首先，我们需要记一个桶来判断特殊情况。
* 为了判断是否存在自由点，我们需要存个 `vector`。
* 小心 Corner Case。

## 反思

这是一道典型的 Atcoder 风格题目，十分考验对题目的直觉和分析。

* $|i - j| \leq k$ 其实会提示你跟区间有关。（在本题里是相邻）
* **直接做十分困难，我们要尝试简化操作。**
* 先把几种简单的情况判掉，否则容易忘考虑。

# C

```
Quality = 低
Difficulty = 2018
Personal_Difficulty = NOIP_T2
Time = 2025.9.23
Tag = 区间DP
```

## 题解

考虑序列最大值，假设 $a_p = n$，那么如果区间 $[l, r]$ 包含 $p$，那么需要判断一下是否满足条件。

那么，整个序列相当于被切成了两段，而这两段显然是互补影响的。

因此，容易想到 $f_{l, r}$ 表示这个区间填数的方案数（我们这里定义填的是 $1$ 到 $r - l + 1$），那么转移如下：

$$
f_{l,  r} = \sum_{l \leq p \leq r} [check(p)]f_{l, p - 1}f_{p + 1, r}\binom{r - l}{p - l}
$$

如何判断 $p$ 是否能作为最大值？相当于我们要看是否存在一个区间 $l <= l_i <= r_i <= r$，使得 $x_i = p$。我们预处理一个 $chk_{l, x}$ 表示当 $l \leq l_i, x_i = x$ 的时候，$r_i$ 的最大值，那么 $chk$ 的转移就是：

$$
chk_{l, x} = \max\{chk_{l + 1, x}, [l_j = l, x_j = x]r_j\}
$$

代码比较好写。

## 总结

* 这种题一般都是考虑最大值。
* 遇到这种题，需要提升写代码的速度（也就是快速把细节搞清楚）

# D

```
Quality = 高
Difficulty = 2880
Personal_Difficulty = NOIP T3.5
Time = 2025.9.23
Tag = 树的重心 DS 思维
```

## 题解

牛牛题啊。

**首先，对于路径长度之和最大的题目，可以找到答案上界。可以发现每条边的贡献最大是两端子树大小 $\min$。**

那么，这里有一个很经典的技巧：将重心定为根，这样，我们只需要保证每条边的子树都被取满即可，而这等价于每条路径都经过根。

然后考虑观察完美匹配，我们发现，设 $c_i$ 为 $i$ 的子树奇偶性，那么有如下条件：

* $c_i = 0$，则儿子中恰有一个 $c_v = 1$
* $c_i = 1$，则儿子的 $c_v = 0$
* $c_{rt} = 0$

根据上面的规则，我们来看一下如何使一棵树删除两个点之后还是完美匹配。两个点太复杂了，我们先考虑如何删除一个点使得前两个条件任然满足。

考虑删除 $u$。那么，如果 $p$ 是 $u$ 的祖先，且 $c_p = 0$，那么 $u$ 删除后 $c_p \to 1$，因此 $c_{fa_p}$ 本来应该是 $1$，也就是 $c_{fa(fa(p))} = 0$，依次类推。我们发现，如果 $u$ 能删，那么 $u$ 到根的路径颜色一定是 $\texttt{01-cross}$ 路径。

因此，我们相当于要选择两个不同子树的点 $x, y$，使得他们到根的路径都是 $\texttt{01-cross}$ 的。显然，有这两颗子树的奇偶性不同。由于我们要保证子树一定能被删完，所以尽量选最大的两棵子树进行删除。

现在的思路十分明了：每次选择两颗各自奇偶性最大的子树，从中选择合法点，然后删除。现在问题是如何选择合法点。

注意到每颗子树互相独立，所以对每颗子树单独固定顺序。我们考虑一个 dfs-like 的东西，假设当前扫到 $u$，分两类：

* $c_u = 0$，那么先选择 $c_v = 1$ 的子树删除，剩下的就可以随便选着删了。
* $c_u = 1$，那么就是随便选子树删。

最后记得删掉 $u$。

这样，我们能保证遍历到 $u$ 的时候，$u$ 到根的路径都是 $\texttt{01-cross}$ 的。因此，如果我们给每颗子树固定好了删除顺序，那么维护两个 `priority_queue` 用来取最大子树，每次按顺序扫指针即可。

## 实现

其实思路很明了了，实现不太需要讲。

## 反思

又是一道典型的 Atcoder 题。ARC 的质量确实高。

* 遇到无从下手的题目，一定要尝试寻找切入点。
* 有时候，观察上下界是一个不错的选择。
* trick：对于路径和最优化问题/出现 $\min{siz_u, siz_v}$，尝试以重心为根。
