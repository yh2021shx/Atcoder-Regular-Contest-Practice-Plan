# C

```
Difficulty = 2009
Personal_Difficulty = NOIP_T2
Time = 2025.9.21
Tag = DP 模拟
```

## 题解

考虑刻画 $C_i = C_j$ 的性质。容易发现，区间形式一定形如 $[l, r], [l + 1, r + 1], \cdots$。

因此，整个序列会被划分成若干个不相交的“块”，不难想到 DP。

设 $f_i$ 表示前 $i$ 个数是否可以划分成功。那么，考虑 push，我们枚举 $[i + 1, r]$，看 $[i + 1, 2r - i - 2]$ 是否满足条件，判断是比较好判断的，但是细节特别多。

## 总结

比较水的一道 2000，但是细节特别多。如果调不出来，一定要好好分析 Corner Case。（针对代码 Hack）

# D

```
Difficulty = 2251
Personal_Difficulty = NOIP_T2.5
Time = 2025.9.22
Tag = DP 思维
```

## 题解

如果直接暴力 DP 的话，我们要记 $f_{i, j, k}$ 表示前 $i$ 个数，选了 $j$ 个，总和为 $k$。复杂度显然起飞。

这里问题出在哪里？我们发现，因为答案是问平均值，所以才要计选了几个数，能否把第二维去掉。

考虑枚举平均值 $x$，那么所有数都可以减去 $x$，将题目转化成求和为 $0$ 的集合个数。

因此，我们可以 DP，设 $f_{i, j}$ 表示前 $i$ 个数和为 $j$ 的方案数，但是时间复杂度 $\mathcal{O}(n ^ 4 \times k)$，优秀了一点，但还是不够。

考虑优化，是否对于所有不同的 $x$，有重复计算的子问题？

**实际上，这里可以考虑将负数和正数划分成两类，然后看和是否互为相反数。这里的好处就是这两个 DP 数组可以预处理，时间复杂度就降到了 $\mathcal{O}(n ^ 3 \times k)$**。

对于平均值为 $x$ 的答案就是：

$$
\sum_{i = 0}^{sum} f_{x - 1, i} \times f_{n - x, i} \times k
$$

因此，总时间复杂度为 $\mathcal{O}(n^3 \times k)$。

## 反思

应该要迅速意识到，这里对于每个答案 $x$，它的 DP 应该有很多重复的部分。然后，考虑分成正数和负数是关键一步。

# E

```
Difficulty = 2824
Personal_Difficulty = NOIP_T2.5
Time = 2025.9.22
Tag = 暴力 计数 DP 
```

## 题解

值域很大，因此我们要对这些区间离散化一下。那么，对于 $l \leq x, y \leq r$，有 $\dfrac{(r - l + 1)(r - l)}{2}$ 种小于/大于的情况，剩下的是等于。

由于 $n \leq 6$，我们可以先枚举所有数的相对顺序，然后看符合这个相对顺序的 $x_i$。问题转化为，每个数能在 $[1, a_i]$ 中取到，要么与前面一个数相等要么大于，问方案数。

那么，容易发现，如果对于一段区间本质不同的数有 $x$ 个，都落在长度为 $l$ 的区间。显然，这样的方案数有 $\binom{l}{x}$ 个。那么，设 $f_{i, j}$ 表示前 $i$ 个数，第 $i$ 个数落在 $j$ 区间，那么每次枚举一段落在同样区间的数即可。

时间复杂度 $\mathcal{O}(n ^ {n + 4})$，但是跑不满。

## 实现

实现难点在于：

* 如何枚举所有数相对顺序？
    * 考虑直接枚举 $n^n$ 个顺序，如果 $[1, mx]$ 中的数没有全部出现，那么不合法。
* DP 的初值是什么？
    * $f_{0, 0} = 1$
* DP 具体怎么转移？
    * 假设当前在转移 $f_{i, j}$，那么枚举 $[l, i]$，$l$ 从右往左扫，每次遇到相对顺序和上一个不同，那么就 `cnt++`，每次转移乘上组合数即可。因此，我们还要预处理组合数。
* 如何刻画“问题转化”？
    * 拿一个数组 `pos`，给他排个序，按照相对顺序排，后面使用这个数组即可。
* 组合数怎么办？
    * 注意到 $\binom{x}{y}$ 的 $x$ 种类很少，$y$ 范围很小，可以递推。

## 总结

* 读题一定要细致，不能想当然。如果可以，看一眼样例解释。
* 写代码前，仔细思考代码细节。

# F

```
Difficulty = 3213
Personal_Difficluty = NOIP_T3
Time = 2025.9.23
Tag = 区间DP 笛卡尔树
```

## 题解

很容易想到考虑最大值的分布，那么对于两个相邻的最大值夹着的区间，他们的 $p_i$ 是独立生成的。

因此，设计 $f_{i, j, v}$ 表示 $[i, j]$ 区间中，所有数都 $\leq v$ 的生成序列数量。转移就是 $f_{i, j, v} = \sum_{i \leq p \leq j}f_{i, p - 1, v}f_{p + 1, j, v - 1}$。（注意，我们要枚举最后一个最大值的位置，才可以使得两个区间互相独立）

**这里有一个很细的细节：考虑整体最大值的笛卡尔树结构，为了避免重复，我们需要让每一个最大值结构都有单独的表示，而在这里就对应着从上往下贪心的填最大的数的情况。**

但现在复杂度是 $\mathcal{O}(n^3V)$ 的，过不了。

这里有一个很有意思的观察：由于序列总共就 $n$ 个，如果我们 $a_i > n$，其实离散化一下后的数组明显不劣，而且 $a_i \leq n$。因此，我们把上界和 $n$ 取 $\min$ 即可。实现较为简单。

## 反思

* 考察最大值是一种常见的思路。

* 但是如果你的 DP 复杂度炸了，不妨看一下有没有无效状态。

* **为了避免重复，要考察每种情况，并给这些情况加条件，在这里就是贪心的填最大值。**
