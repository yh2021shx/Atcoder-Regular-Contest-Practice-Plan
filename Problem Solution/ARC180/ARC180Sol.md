# C

```
Quality = 中
Difficulty = 2000
Personal_Difficulty = NOIP_T2.5
Time = 2025.9.27
Tag = DP 计数
```

## 题解

由子序列，不难想到 DP。

我们考虑一个序列什么时候会重复，我们先从简单的情况开始考虑。容易发现，当我们选择的数的和 $S$ 等于我们选择的最后一个元素时，最后一个元素没有修改，因此这个序列一定会重复。

考虑往这样重复的序列后面增加数，我们发现虽然这个值没有更改，但是对后面的数是有影响的。

回归到 DP，我们设 $f_{i, j}$ 表示前 $i$ 个数选择的数和为 $j$ 能生成的序列数。我们发现，如果要对和为 $j$ 的情况后面再选择一个 $a_i$，有如下几种情况：

* $j = 0$，这时答案一定重复，不能计入。
* 本来最后一个数就会被更改，这时再加入一个数。
* 本来最后一个数不会被更改。

前面两种情况都很简单，但是第三种情况会重复。我们发现，如果两个不会被更改的结尾 $a_x, a_y(x < y)$，他们的值相等，那么 $a_y$ 结尾的方案一定会包含 $a_x$ 结尾的方案，所以只存对于相等的 $a_i$ 中最靠后的那一个方案数。

因此，设计 $g_i$ 表示当最后一个数为 $i$ 且前面的数和为 $0$ 所生成的方案数即可。

## 反思

* **从简单的情况入手。**

# D

```
Quality = 低
Difficulty = 2227
Personal_Difficulty = NOIP_T2.5
Time = 2025.9.27
Tag = DS
```

首先，容易想到考虑最大值。那么我们考虑最大值在哪个位置。

如果最大值在中间的区间，那么答案一定是 $a_l + a_r + mx$。最大值在两边的情况对称，因此只讨论一边。

假设最大值在右边的区间，那么我们考虑枚举最左边的区间构成。假设最左边的是 $[l, x]$，显然，中间的一定是 $[x + 1, x + 1]$，因此答案是 $mx_L + a_{x + 1} + mx$。这个可以用单调栈+线段树维护。

## 总结

不算很难。

* 重点在考虑区间最大值上。
